#!/usr/bin/env python3
"""
Script untuk Export Semua Data dari Database PostgreSQL PZEM Monitoring
Support export format: SQL, CSV, JSON
"""

import psycopg2
from psycopg2.extras import RealDictCursor, Json
import json
import csv
import os
import sys
from datetime import datetime
import argparse

# Konfigurasi Database (sama dengan project)
DB_CONFIG = {
    'host': os.getenv('DB_HOST', 'localhost'),
    'database': os.getenv('DB_NAME', 'pzem_monitoring'),
    'user': os.getenv('DB_USER', 'postgres'),
    'password': os.getenv('DB_PASS', 'Admin123'),
    'port': os.getenv('DB_PORT', '5432')
}

class DatabaseExporter:
    def __init__(self, db_config):
        self.db_config = db_config
        self.connection = None
        self.connect()
    
    def connect(self):
        """Koneksi ke database"""
        try:
            self.connection = psycopg2.connect(**self.db_config)
            print(f"âœ“ Berhasil terhubung ke database: {self.db_config['database']}@{self.db_config['host']}")
        except Exception as e:
            print(f"âœ— Error koneksi database: {e}")
            sys.exit(1)
    
    def get_table_names(self):
        """Mendapatkan daftar semua tabel"""
        cursor = self.connection.cursor()
        cursor.execute("""
            SELECT table_name 
            FROM information_schema.tables 
            WHERE table_schema = 'public' 
            AND table_type = 'BASE TABLE'
            ORDER BY table_name;
        """)
        tables = [row[0] for row in cursor.fetchall()]
        cursor.close()
        return tables
    
    def get_table_info(self, table_name):
        """Mendapatkan informasi kolom tabel"""
        cursor = self.connection.cursor()
        cursor.execute("""
            SELECT column_name, data_type, character_maximum_length
            FROM information_schema.columns
            WHERE table_name = %s
            ORDER BY ordinal_position;
        """, (table_name,))
        columns = cursor.fetchall()
        cursor.close()
        return columns
    
    def get_row_count(self, table_name):
        """Mendapatkan jumlah baris dalam tabel"""
        cursor = self.connection.cursor()
        cursor.execute(f"SELECT COUNT(*) FROM {table_name};")
        count = cursor.fetchone()[0]
        cursor.close()
        return count
    
    def get_order_by_column(self, table_name):
        """Mendapatkan kolom yang bisa digunakan untuk ORDER BY"""
        columns_info = self.get_table_info(table_name)
        column_names = [col[0] for col in columns_info]
        
        # Prioritas: id > created_at > updated_at > kolom pertama
        if 'id' in column_names:
            return 'id'
        elif 'created_at' in column_names:
            return 'created_at'
        elif 'updated_at' in column_names:
            return 'updated_at'
        elif column_names:
            return column_names[0]  # Kolom pertama sebagai fallback
        else:
            return None  # Tidak ada kolom untuk sorting
    
    def export_to_sql(self, output_file):
        """Export ke format SQL dump"""
        print(f"\nðŸ“„ Exporting ke SQL: {output_file}")
        
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write(f"-- PostgreSQL Database Export\n")
            f.write(f"-- Database: {self.db_config['database']}\n")
            f.write(f"-- Export Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
            f.write(f"-- Generated by PZEM Database Exporter\n\n")
            
            tables = self.get_table_names()
            
            for table in tables:
                print(f"  â†’ Exporting table: {table}")
                row_count = self.get_row_count(table)
                print(f"    Rows: {row_count:,}")
                
                # Get table structure
                columns_info = self.get_table_info(table)
                column_names = [col[0] for col in columns_info]
                
                f.write(f"\n-- Table: {table} ({row_count} rows)\n")
                f.write(f"TRUNCATE TABLE {table} CASCADE;\n\n")
                
                # Get all data dengan ORDER BY yang sesuai
                cursor = self.connection.cursor()
                order_by_col = self.get_order_by_column(table)
                if order_by_col:
                    query = f"SELECT * FROM {table} ORDER BY {order_by_col} ASC;"
                else:
                    query = f"SELECT * FROM {table};"
                cursor.execute(query)
                
                batch_size = 1000
                rows_exported = 0
                
                while True:
                    rows = cursor.fetchmany(batch_size)
                    if not rows:
                        break
                    
                    for row in rows:
                        values = []
                        for i, val in enumerate(row):
                            if val is None:
                                values.append('NULL')
                            elif isinstance(val, (int, float)):
                                values.append(str(val))
                            elif isinstance(val, datetime):
                                values.append(f"'{val.isoformat()}'")
                            elif isinstance(val, str):
                                # Escape single quotes
                                val_escaped = val.replace("'", "''")
                                values.append(f"'{val_escaped}'")
                            else:
                                val_escaped = str(val).replace("'", "''")
                                values.append(f"'{val_escaped}'")
                        
                        columns_str = ', '.join([f'"{col}"' for col in column_names])
                        values_str = ', '.join(values)
                        f.write(f"INSERT INTO {table} ({columns_str}) VALUES ({values_str});\n")
                        rows_exported += 1
                    
                    if rows_exported % 10000 == 0:
                        print(f"    Exported {rows_exported:,} rows...")
                
                cursor.close()
                print(f"    âœ“ Completed: {rows_exported:,} rows exported")
        
        print(f"\nâœ“ SQL export completed: {output_file}")
    
    def export_to_csv(self, output_dir):
        """Export setiap tabel ke file CSV terpisah"""
        print(f"\nðŸ“Š Exporting ke CSV: {output_dir}")
        
        os.makedirs(output_dir, exist_ok=True)
        tables = self.get_table_names()
        
        for table in tables:
            print(f"  â†’ Exporting table: {table}")
            csv_file = os.path.join(output_dir, f"{table}.csv")
            
            row_count = self.get_row_count(table)
            print(f"    Rows: {row_count:,}")
            
            cursor = self.connection.cursor(cursor_factory=RealDictCursor)
            order_by_col = self.get_order_by_column(table)
            if order_by_col:
                query = f"SELECT * FROM {table} ORDER BY {order_by_col} ASC;"
            else:
                query = f"SELECT * FROM {table};"
            cursor.execute(query)
            
            # Get column names
            column_names = [desc[0] for desc in cursor.description]
            
            with open(csv_file, 'w', newline='', encoding='utf-8') as f:
                writer = csv.DictWriter(f, fieldnames=column_names)
                writer.writeheader()
                
                batch_size = 1000
                rows_exported = 0
                
                while True:
                    rows = cursor.fetchmany(batch_size)
                    if not rows:
                        break
                    
                    for row in rows:
                        # Convert datetime and other objects to strings
                        row_dict = {}
                        for key, value in row.items():
                            if isinstance(value, datetime):
                                row_dict[key] = value.isoformat()
                            elif isinstance(value, (int, float)):
                                row_dict[key] = value
                            else:
                                row_dict[key] = str(value) if value is not None else ''
                        writer.writerow(row_dict)
                        rows_exported += 1
                    
                    if rows_exported % 10000 == 0:
                        print(f"    Exported {rows_exported:,} rows...")
            
            cursor.close()
            print(f"    âœ“ Completed: {rows_exported:,} rows exported to {csv_file}")
        
        print(f"\nâœ“ CSV export completed: {output_dir}")
    
    def export_to_json(self, output_file):
        """Export ke format JSON"""
        print(f"\nðŸ“‹ Exporting ke JSON: {output_file}")
        
        tables = self.get_table_names()
        export_data = {
            'database': self.db_config['database'],
            'export_date': datetime.now().isoformat(),
            'tables': {}
        }
        
        for table in tables:
            print(f"  â†’ Exporting table: {table}")
            row_count = self.get_row_count(table)
            print(f"    Rows: {row_count:,}")
            
            cursor = self.connection.cursor(cursor_factory=RealDictCursor)
            order_by_col = self.get_order_by_column(table)
            if order_by_col:
                query = f"SELECT * FROM {table} ORDER BY {order_by_col} ASC;"
            else:
                query = f"SELECT * FROM {table};"
            cursor.execute(query)
            
            rows = []
            batch_size = 1000
            rows_exported = 0
            
            while True:
                batch = cursor.fetchmany(batch_size)
                if not batch:
                    break
                
                for row in batch:
                    # Convert to dict and handle datetime objects
                    row_dict = {}
                    for key, value in row.items():
                        if isinstance(value, datetime):
                            row_dict[key] = value.isoformat()
                        elif isinstance(value, (int, float)):
                            row_dict[key] = value
                        else:
                            row_dict[key] = value
                    rows.append(row_dict)
                    rows_exported += 1
                
                if rows_exported % 10000 == 0:
                    print(f"    Exported {rows_exported:,} rows...")
            
            export_data['tables'][table] = {
                'row_count': rows_exported,
                'data': rows
            }
            
            cursor.close()
            print(f"    âœ“ Completed: {rows_exported:,} rows exported")
        
        # Write to JSON file
        with open(output_file, 'w', encoding='utf-8') as f:
            json.dump(export_data, f, indent=2, ensure_ascii=False, default=str)
        
        print(f"\nâœ“ JSON export completed: {output_file}")
    
    def show_summary(self):
        """Menampilkan ringkasan database"""
        print("\n" + "="*60)
        print("DATABASE SUMMARY")
        print("="*60)
        print(f"Database: {self.db_config['database']}")
        print(f"Host: {self.db_config['host']}")
        print(f"User: {self.db_config['user']}")
        print()
        
        tables = self.get_table_names()
        total_rows = 0
        
        for table in tables:
            row_count = self.get_row_count(table)
            total_rows += row_count
            columns_info = self.get_table_info(table)
            print(f"Table: {table}")
            print(f"  Rows: {row_count:,}")
            print(f"  Columns: {len(columns_info)}")
            for col in columns_info:
                col_type = col[1]
                if col[2]:
                    col_type += f"({col[2]})"
                print(f"    - {col[0]}: {col_type}")
            print()
        
        print(f"Total Tables: {len(tables)}")
        print(f"Total Rows: {total_rows:,}")
        print("="*60)
    
    def close(self):
        """Tutup koneksi"""
        if self.connection:
            self.connection.close()
            print("\nâœ“ Database connection closed")

def main():
    parser = argparse.ArgumentParser(
        description='Export semua data dari database PostgreSQL PZEM Monitoring',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Contoh penggunaan:
  # Export ke SQL
  python export_database.py --format sql --output backup.sql
  
  # Export ke CSV
  python export_database.py --format csv --output exports/
  
  # Export ke JSON
  python export_database.py --format json --output backup.json
  
  # Export semua format
  python export_database.py --format all
  
  # Custom database connection
  python export_database.py --host 192.168.1.100 --db mydb --user myuser --pass mypass
  
  # Hanya lihat summary
  python export_database.py --summary
        """
    )
    
    parser.add_argument('--format', '-f', 
                       choices=['sql', 'csv', 'json', 'all'],
                       default='all',
                       help='Format export (default: all)')
    
    parser.add_argument('--output', '-o',
                       help='Output file atau directory (default: auto-generated)')
    
    parser.add_argument('--host',
                       help='Database host (override DB_HOST env)')
    
    parser.add_argument('--db', '--database',
                       dest='database',
                       help='Database name (override DB_NAME env)')
    
    parser.add_argument('--user', '-u',
                       help='Database user (override DB_USER env)')
    
    parser.add_argument('--pass', '-p',
                       dest='password',
                       help='Database password (override DB_PASS env)')
    
    parser.add_argument('--port',
                       help='Database port (override DB_PORT env, default: 5432)')
    
    parser.add_argument('--summary', '-s',
                       action='store_true',
                       help='Hanya tampilkan summary database, tidak export')
    
    args = parser.parse_args()
    
    # Override config dengan command line arguments
    config = DB_CONFIG.copy()
    if args.host:
        config['host'] = args.host
    if args.database:
        config['database'] = args.database
    if args.user:
        config['user'] = args.user
    if args.password:
        config['password'] = args.password
    if args.port:
        config['port'] = args.port
    
    # Create exporter
    exporter = DatabaseExporter(config)
    
    # Show summary
    exporter.show_summary()
    
    if args.summary:
        exporter.close()
        return
    
    # Generate output filename/directory
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    
    if args.format == 'sql' or args.format == 'all':
        sql_file = args.output or f'pzem_backup_{timestamp}.sql'
        exporter.export_to_sql(sql_file)
    
    if args.format == 'csv' or args.format == 'all':
        csv_dir = args.output or f'pzem_export_csv_{timestamp}'
        exporter.export_to_csv(csv_dir)
    
    if args.format == 'json' or args.format == 'all':
        json_file = args.output or f'pzem_backup_{timestamp}.json'
        exporter.export_to_json(json_file)
    
    exporter.close()
    
    print("\nâœ… Export selesai!")
    print(f"\nTips:")
    print(f"  - File SQL dapat di-restore dengan: psql -U postgres -d pzem_monitoring < backup.sql")
    print(f"  - File CSV dapat dibuka dengan Excel atau aplikasi spreadsheet")
    print(f"  - File JSON dapat dibaca dengan text editor atau program Python")

if __name__ == '__main__':
    main()




name: CD - Deploy to Production VPS

on:
  push:
    branches: [ main, master ]
    paths:
      - 'pzem-monitoring/V9-Docker/**'
      - '.github/workflows/**'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging

env:
  VPS_USER: foom
  VPS_HOST: ${{ secrets.VPS_HOST || '103.31.39.189' }}
  VPS_DEPLOY_DIR: /opt/pzem-monitoring
  PROJECT_DIR: pzem-monitoring/V9-Docker

jobs:
  deploy:
    name: Deploy to VPS
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master' || github.event_name == 'workflow_dispatch'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup SSH
      run: |
        set +e  # Don't fail on errors in this step
        
        mkdir -p ~/.ssh
        chmod 700 ~/.ssh
        
        # Write private key to file (preserve newlines)
        echo "${{ secrets.VPS_SSH_KEY }}" > ~/.ssh/deploy_key
        chmod 600 ~/.ssh/deploy_key
        
        # Verify key file was created
        if [ ! -f ~/.ssh/deploy_key ]; then
          echo "‚ùå Error: Failed to create deploy_key file"
          exit 1
        fi
        
        # Check key format
        if ! grep -q "BEGIN.*PRIVATE KEY" ~/.ssh/deploy_key; then
          echo "‚ö†Ô∏è  Warning: Key format may be incorrect (missing BEGIN line)"
        fi
        
        # Add VPS to known hosts
        ssh-keyscan -H ${{ env.VPS_HOST }} >> ~/.ssh/known_hosts 2>/dev/null || true
        chmod 600 ~/.ssh/known_hosts
        
        # Test SSH connection (non-blocking)
        echo "üîç Testing SSH connection..."
        SSH_TEST_OUTPUT=$(ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -o ConnectTimeout=10 -o BatchMode=yes ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "echo 'SSH connection test successful'" 2>&1)
        SSH_EXIT_CODE=$?
        
        if [ $SSH_EXIT_CODE -eq 0 ]; then
          echo "‚úÖ SSH connection test successful"
        else
          echo "‚ö†Ô∏è  Warning: SSH connection test failed (exit code: $SSH_EXIT_CODE)"
          echo "   Error output: $SSH_TEST_OUTPUT"
          echo "   This may be due to:"
          echo "   - Key format issue (check GitHub Secret VPS_SSH_KEY)"
          echo "   - Key not matching VPS authorized_keys"
          echo "   - Network connectivity issue"
          echo "   - VPS host unreachable"
          echo ""
          echo "   Debug info:"
          echo "   - Key file exists: $([ -f ~/.ssh/deploy_key ] && echo 'yes' || echo 'no')"
          echo "   - Key file size: $(wc -c < ~/.ssh/deploy_key) bytes"
          echo "   - Key starts with BEGIN: $(head -1 ~/.ssh/deploy_key | grep -q 'BEGIN' && echo 'yes' || echo 'no')"
          echo ""
          echo "   Continuing with deployment attempt (may fail at upload step)..."
        fi
        
        set -e  # Re-enable error checking

    - name: Create deployment package
      run: |
        TIMESTAMP=$(date +%Y%m%d_%H%M%S)
        PACKAGE_NAME="pzem-monitoring-deploy-${TIMESTAMP}.tar.gz"
        
        # Create package from V9-Docker directory
        # Note: --exclude options must come before files/directories
        cd ${PROJECT_DIR}
        
        # Build list of files to include
        FILES_TO_INCLUDE="dashboard/ mqtt/ docker-compose.yml"
        
        # Add important files if they exist
        [ -f "start.sh" ] && FILES_TO_INCLUDE="$FILES_TO_INCLUDE start.sh"
        [ -f "nginx-pzem.conf" ] && FILES_TO_INCLUDE="$FILES_TO_INCLUDE nginx-pzem.conf"
        [ -f "setup-nginx-ssl.sh" ] && FILES_TO_INCLUDE="$FILES_TO_INCLUDE setup-nginx-ssl.sh"
        
        # Add markdown files if any exist (for documentation)
        if ls *.md 1> /dev/null 2>&1; then
          FILES_TO_INCLUDE="$FILES_TO_INCLUDE *.md"
        fi
        
        echo "üì¶ Files to include in package:"
        echo "$FILES_TO_INCLUDE"
        
        # Create tar archive with excludes before files
        tar -czf ../../${PACKAGE_NAME} \
          --exclude='*.pyc' \
          --exclude='__pycache__' \
          --exclude='*.log' \
          --exclude='*.pdf' \
          --exclude='*.zip' \
          --exclude='*.tar.gz' \
          --exclude='.git' \
          $FILES_TO_INCLUDE
        
        cd ../..
        echo "PACKAGE_NAME=${PACKAGE_NAME}" >> $GITHUB_ENV
        echo "‚úÖ Package created: ${PACKAGE_NAME}"

    - name: Upload package to VPS
      run: |
        # Retry function for SCP
        MAX_RETRIES=3
        RETRY_COUNT=0
        SCP_SUCCESS=false
        
        while [ $RETRY_COUNT -lt $MAX_RETRIES ] && [ "$SCP_SUCCESS" = false ]; do
          RETRY_COUNT=$((RETRY_COUNT + 1))
          echo "üì§ Upload attempt $RETRY_COUNT of $MAX_RETRIES..."
          
          if scp -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -o ConnectTimeout=30 -o ServerAliveInterval=10 ${PACKAGE_NAME} ${{ env.VPS_USER }}@${{ env.VPS_HOST }}:/tmp/ 2>&1; then
            SCP_SUCCESS=true
            echo "‚úÖ Package uploaded to VPS"
          else
            SCP_EXIT_CODE=$?
            echo "‚ö†Ô∏è  Upload failed with exit code: $SCP_EXIT_CODE"
            
            if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
              WAIT_TIME=$((RETRY_COUNT * 15))
              echo "   Waiting ${WAIT_TIME} seconds before retry..."
              sleep $WAIT_TIME
            else
              echo "‚ùå Upload failed after $MAX_RETRIES attempts"
              echo "   Possible causes:"
              echo "   - VPS is unreachable (check if VPS is running)"
              echo "   - Network connectivity issues"
              echo "   - Firewall blocking connection"
              echo "   - SSH service not running on VPS"
              exit 1
            fi
          fi
        done

    - name: Create remote deployment script
      run: |
        cat > /tmp/remote-deploy.sh << 'REMOTE_SCRIPT'
        #!/bin/bash
        set -e
        
        VPS_DEPLOY_DIR="/opt/pzem-monitoring"
        # Use home directory for backups (user has permission there)
        BACKUP_DIR="${HOME}/.pzem-backups"
        PACKAGE_FILE=$(ls /tmp/pzem-monitoring-deploy-*.tar.gz | head -1)
        
        # Detect docker-compose
        if command -v docker-compose &> /dev/null; then
          DOCKER_COMPOSE="docker-compose"
        elif docker compose version &> /dev/null; then
          DOCKER_COMPOSE="docker compose"
        else
          echo "‚ùå ERROR: docker-compose not found"
          exit 1
        fi
        
        echo "üîß Starting deployment to ${VPS_DEPLOY_DIR}..."
        
        # Backup existing (if exists)
        if [ -d "${VPS_DEPLOY_DIR}" ]; then
          echo "üì¶ Creating backup..."
          # Create backup directory (use home directory to avoid permission issues)
          mkdir -p "${BACKUP_DIR}" || {
            echo "‚ö†Ô∏è  Warning: Cannot create backup directory ${BACKUP_DIR}, trying alternative location..."
            BACKUP_DIR="${VPS_DEPLOY_DIR}/.backups"
            mkdir -p "${BACKUP_DIR}" || {
              echo "‚ö†Ô∏è  Warning: Cannot create backup directory, skipping backup..."
              BACKUP_DIR=""
            }
          }
          
          if [ -f "${VPS_DEPLOY_DIR}/docker-compose.yml" ]; then
            cd "${VPS_DEPLOY_DIR}"
            
            # Backup database if container running and backup directory exists
            if [ -n "${BACKUP_DIR}" ] && docker ps | grep -q "pzem-monitoring.*db\|.*db.*pzem"; then
              DB_CONTAINER=$(docker ps | grep -E "pzem-monitoring.*db|.*db.*pzem" | awk '{print $1}' | head -1)
              if [ -n "$DB_CONTAINER" ]; then
                echo "üíæ Backing up database..."
                docker exec ${DB_CONTAINER} pg_dump -U postgres pzem_monitoring > "${BACKUP_DIR}/database_backup_$(date +%Y%m%d_%H%M%S).sql" 2>/dev/null || echo "‚ö†Ô∏è  Database backup failed (non-critical)"
                echo "‚úÖ Database backup completed"
              fi
            fi
            
            # Backup .env if backup directory exists
            if [ -n "${BACKUP_DIR}" ] && [ -f "${VPS_DEPLOY_DIR}/.env" ]; then
              cp "${VPS_DEPLOY_DIR}/.env" "${BACKUP_DIR}/.env.backup.$(date +%Y%m%d_%H%M%S)" || echo "‚ö†Ô∏è  .env backup failed (non-critical)"
              echo "‚úÖ .env backed up"
            fi
            
            # Stop services (preserve volumes)
            echo "üõë Stopping services..."
            $DOCKER_COMPOSE down 2>/dev/null || true
            sleep 5
          fi
          
          # Backup directory
          BACKUP_NAME="${VPS_DEPLOY_DIR}_backup_$(date +%Y%m%d_%H%M%S)"
          echo "üì¶ Backing up directory to ${BACKUP_NAME}..."
          mv "${VPS_DEPLOY_DIR}" "${BACKUP_NAME}" || true
        fi
        
        # Extract new package
        echo "üì¶ Extracting package..."
        mkdir -p "${VPS_DEPLOY_DIR}"
        cd "${VPS_DEPLOY_DIR}"
        tar -xzf "${PACKAGE_FILE}"
        
        # Restore .env if exists and backup directory is available
        if [ -n "${BACKUP_DIR}" ] && [ -f "${BACKUP_DIR}/.env.backup."* ] 2>/dev/null; then
          LATEST_ENV=$(ls -t "${BACKUP_DIR}/.env.backup."* 2>/dev/null | head -1)
          if [ -n "${LATEST_ENV}" ] && [ -f "${LATEST_ENV}" ]; then
            cp "${LATEST_ENV}" "${VPS_DEPLOY_DIR}/.env"
            echo "‚úÖ .env restored from backup"
          else
            echo "‚ö†Ô∏è  No .env backup found - using default configuration"
          fi
        else
          echo "‚ö†Ô∏è  No .env backup found - using default configuration"
        fi
        
        # Make scripts executable
        chmod +x ${VPS_DEPLOY_DIR}/*.sh 2>/dev/null || true
        
        # Check network connectivity before build
        echo "üåê Checking network connectivity..."
        if ! timeout 10 ping -c 1 8.8.8.8 > /dev/null 2>&1 && ! timeout 10 ping -c 1 1.1.1.1 > /dev/null 2>&1; then
          echo "‚ö†Ô∏è  Warning: Network connectivity check failed"
          echo "   This may cause Docker build to fail"
        else
          echo "‚úÖ Network connectivity OK"
        fi
        
        # Check Docker Hub connectivity
        echo "üê≥ Checking Docker Hub connectivity..."
        if ! timeout 10 curl -s https://auth.docker.io > /dev/null 2>&1; then
          echo "‚ö†Ô∏è  Warning: Cannot reach Docker Hub"
          echo "   Will try to build anyway, but may fail"
        else
          echo "‚úÖ Docker Hub reachable"
        fi
        
        # Build and start
        echo "üî® Building containers..."
        cd "${VPS_DEPLOY_DIR}"
        
        # Try build with retry mechanism
        BUILD_SUCCESS=false
        MAX_RETRIES=3
        RETRY_COUNT=0
        
        while [ $RETRY_COUNT -lt $MAX_RETRIES ] && [ "$BUILD_SUCCESS" = false ]; do
          RETRY_COUNT=$((RETRY_COUNT + 1))
          echo "   Build attempt $RETRY_COUNT of $MAX_RETRIES..."
          
          if $DOCKER_COMPOSE build --no-cache 2>&1; then
            BUILD_SUCCESS=true
            echo "‚úÖ Build successful"
          else
            BUILD_EXIT_CODE=$?
            echo "‚ö†Ô∏è  Build failed with exit code: $BUILD_EXIT_CODE"
            
            if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
              WAIT_TIME=$((RETRY_COUNT * 10))
              echo "   Waiting ${WAIT_TIME} seconds before retry..."
              sleep $WAIT_TIME
            else
              echo "‚ùå Build failed after $MAX_RETRIES attempts"
              echo "   This may be due to network issues or Docker Hub being unavailable"
              echo "   Attempting to start with existing images (if available)..."
              
              # Check if images exist locally
              if docker images | grep -q "pzem-monitoring.*dashboard\|.*dashboard.*pzem" || \
                 docker images | grep -q "pzem-monitoring.*mqtt\|.*mqtt.*pzem"; then
                echo "   Found existing images, will try to use them"
                BUILD_SUCCESS=true  # Continue with existing images
              else
                echo "   No existing images found, deployment will fail"
                exit 1
              fi
            fi
          fi
        done
        
        echo "üöÄ Starting services..."
        $DOCKER_COMPOSE up -d
        
        # Wait for services
        echo "‚è≥ Waiting for services to start..."
        sleep 20
        
        # Verify database
        echo "üîç Verifying database..."
        MAX_RETRIES=30
        RETRY_COUNT=0
        DB_READY=false
        
        while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
          if $DOCKER_COMPOSE exec -T db pg_isready -U postgres > /dev/null 2>&1; then
            DB_READY=true
            break
          fi
          RETRY_COUNT=$((RETRY_COUNT + 1))
          echo "   Waiting for database... ($RETRY_COUNT/$MAX_RETRIES)"
          sleep 2
        done
        
        if [ "$DB_READY" = true ]; then
          echo "‚úÖ Database is ready"
        else
          echo "‚ùå Database did not become ready"
          exit 1
        fi
        
        # Health check
        echo "üè• Health check..."
        sleep 10
        if curl -f -s http://localhost:5000/health > /dev/null 2>&1 || curl -f -s http://localhost:5000/ > /dev/null 2>&1; then
          echo "‚úÖ Health check passed"
        else
          echo "‚ö†Ô∏è  Health check failed (service may still be starting)"
        fi
        
        # Cleanup
        rm -f "${PACKAGE_FILE}"
        
        echo "‚úÖ Deployment completed successfully!"
        echo "üìç Location: ${VPS_DEPLOY_DIR}"
        REMOTE_SCRIPT
        
        # Upload deployment script with retry
        MAX_RETRIES=3
        RETRY_COUNT=0
        SCRIPT_UPLOAD_SUCCESS=false
        
        while [ $RETRY_COUNT -lt $MAX_RETRIES ] && [ "$SCRIPT_UPLOAD_SUCCESS" = false ]; do
          RETRY_COUNT=$((RETRY_COUNT + 1))
          echo "üì§ Uploading deployment script (attempt $RETRY_COUNT of $MAX_RETRIES)..."
          
          if scp -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -o ConnectTimeout=30 -o ServerAliveInterval=10 /tmp/remote-deploy.sh ${{ env.VPS_USER }}@${{ env.VPS_HOST }}:/tmp/ 2>&1; then
            SCRIPT_UPLOAD_SUCCESS=true
            echo "‚úÖ Deployment script uploaded"
          else
            if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
              WAIT_TIME=$((RETRY_COUNT * 15))
              echo "   Waiting ${WAIT_TIME} seconds before retry..."
              sleep $WAIT_TIME
            else
              echo "‚ùå Failed to upload deployment script after $MAX_RETRIES attempts"
              exit 1
            fi
          fi
        done

    - name: Execute deployment on VPS
      run: |
        # Execute deployment with retry
        MAX_RETRIES=3
        RETRY_COUNT=0
        DEPLOY_SUCCESS=false
        
        while [ $RETRY_COUNT -lt $MAX_RETRIES ] && [ "$DEPLOY_SUCCESS" = false ]; do
          RETRY_COUNT=$((RETRY_COUNT + 1))
          echo "üöÄ Deployment attempt $RETRY_COUNT of $MAX_RETRIES..."
          
          if ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -o ConnectTimeout=30 -o ServerAliveInterval=10 ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "chmod +x /tmp/remote-deploy.sh && bash /tmp/remote-deploy.sh" 2>&1; then
            DEPLOY_SUCCESS=true
            echo "‚úÖ Deployment executed successfully"
          else
            DEPLOY_EXIT_CODE=$?
            echo "‚ö†Ô∏è  Deployment failed with exit code: $DEPLOY_EXIT_CODE"
            
            if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
              WAIT_TIME=$((RETRY_COUNT * 15))
              echo "   Waiting ${WAIT_TIME} seconds before retry..."
              sleep $WAIT_TIME
            else
              echo "‚ùå Deployment failed after $MAX_RETRIES attempts"
              exit 1
            fi
          fi
        done

    - name: Verify deployment
      run: |
        # Verify with retry
        MAX_RETRIES=2
        RETRY_COUNT=0
        VERIFY_SUCCESS=false
        
        while [ $RETRY_COUNT -lt $MAX_RETRIES ] && [ "$VERIFY_SUCCESS" = false ]; do
          RETRY_COUNT=$((RETRY_COUNT + 1))
          echo "üîç Verification attempt $RETRY_COUNT of $MAX_RETRIES..."
          
          if ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -o ConnectTimeout=30 -o ServerAliveInterval=10 ${{ env.VPS_USER }}@${{ env.VPS_HOST }} << 'EOF'
          cd ${{ env.VPS_DEPLOY_DIR }}
          echo "üìä Service Status:"
          if command -v docker-compose &> /dev/null; then
            docker-compose ps
          elif docker compose version &> /dev/null; then
            docker compose ps
          fi
          echo ""
          echo "üê≥ Running containers:"
          docker ps --filter "name=pzem" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
        EOF
          then
            VERIFY_SUCCESS=true
            echo "‚úÖ Verification successful"
          else
            if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
              echo "   Waiting 10 seconds before retry..."
              sleep 10
            else
              echo "‚ö†Ô∏è  Verification failed, but deployment may still be successful"
              VERIFY_SUCCESS=true  # Don't fail the job
            fi
          fi
        done

    - name: Cleanup local files
      if: always()
      run: |
        rm -f ${PACKAGE_NAME}
        rm -f /tmp/remote-deploy.sh
        rm -f ~/.ssh/deploy_key

    - name: Deployment summary
      if: always()
      run: |
        echo "## üöÄ Deployment Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "- **Status**: ${{ job.status }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Branch**: ${{ github.ref }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Commit**: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
        echo "- **VPS**: ${{ env.VPS_USER }}@${{ env.VPS_HOST }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Deploy Path**: ${{ env.VPS_DEPLOY_DIR }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Access URLs" >> $GITHUB_STEP_SUMMARY
        echo "- Dashboard: http://${{ env.VPS_HOST }}:5000" >> $GITHUB_STEP_SUMMARY
        echo "- Health: http://${{ env.VPS_HOST }}:5000/health" >> $GITHUB_STEP_SUMMARY
